

window.xUtil.fixTestGlobals()
Stream = require( 'js/util/Stream' )


beforeAll () ->
  stream = new Stream()
  Util.noop( stream )
  @test = new Test()

class Test

  @toStrArgs:() -> Util.toStrArgs('Test:',arguments)

  constructor:() ->
    @obj = {}
    @obj.method = () -> 'Hi'

describe("util/Util.coffee", () ->
  ###
  it("hasMethod",              () -> expect( Util.hasMethod(  @test.obj, 'method'    ) ).toBe(true)  )
  it("hasGlobal",              () -> expect( Util.hasGlobal( 'Util'            ) ).toBe(true)  )
  it("hasGlobal",              () -> expect( Util.getGlobal( 'fullScreen'      ) ).toBe(false) )
  it("hasPlugin",              () -> expect( Util.hasPlugin( 'Util.hasPlugin'  ) ).toBe(true)  )
  it("hasModule",              () -> expect( Util.hasModule( 'util/Util'       ) ).toBe(true)  )
  it("dependsOn(global)",      () -> expect( Util.dependsOn( 'jasmine'         ) ).toBe(true)  )
  it("dependsOn(module)",      () -> expect( Util.dependsOn( 'util/Util'       ) ).toBe(true)  )
  it("dependsOn(plugin)",      () -> expect( Util.dependsOn( 'Util.hasPlugin'  ) ).toBe(true)  )
  it("Export Import",          () -> # Util.Export(   Util,'zzz/Util'); expect(true).toBe( require(    'js/util/Util').testTrue ) )
  it("setModule   getModule",  () -> Util.setModule(Util,'yyy/Util'); expect(true).toBe( Util.getModule('js/util/Util').testTrue ) )
  it("setInstance getInstance",() -> Util.setInstance('xx','xx');      expect('xx').toEqual( Util.getInstance('xx') ) )
  ###
  it("toStr",     () -> expect( Util.toStr(null)      ).toEqual( 'null'         ) )
  it("toStr",     () -> expect( Util.toStr('1')       ).toEqual( '1'            ) )
  it("toStr",     () -> expect( Util.toStr(1)         ).toEqual( '1'            ) )
  it("toStr",     () -> expect( Util.toStr(1.0)       ).toEqual( '1'          ) )
  it("toStr",     () -> expect( Util.toStr({a:1,b:2}) ).toEqual( '{ a:1, b:2 }' ) )
  it("toStrStr",  () -> expect( Util.toStrStr('str')   ).toEqual( 'str'          ) )
  it("toStrStr",  () -> expect( Util.toStrStr('')      ).toEqual( '""'           ) )
  it("toStrArgs", () -> expect( Test.toStrArgs('a',1,{a:1,b:2}) ).toEqual( 'Test: a 1 { a:1, b:2 } ' ) )
  it("toStrObj",  () -> expect( Util.toStrObj({a:1,b:2}) )       .toEqual( '{ a:1, b:2 }' ) )

  it('isDef:(d)',         () -> expect( Util.isDef(Util.testTrue)    ).toBe(true) )
  it('isStr:(s)',         () -> expect( Util.isStr('1')              ).toBe(true) )
  it('isNum:(n)',         () -> expect( Util.isNum( 1)               ).toBe(true) )
  it('isObj:(o)',         () -> expect( Util.isObj({a:1,b:2})        ).toBe(true) )
  it('isObjEmpty:(o)',    () -> expect( Util.isObjEmpty({})          ).toBe(true) )
  it('isFunc:(f)',        () -> expect( Util.isFunc(Util.isFunc)     ).toBe(true) )
  it('isArray:(a)',       () -> expect( Util.isArray([1,2])          ).toBe(true) )
  it('isEvent:(e)',       () -> expect( Util.isEvent({target:1})     ).toBe(true) )
  it('inIndex:(a,i)',     () -> expect( Util.inIndex( [1,2],1)       ).toBe(true) )
  it('inArray:(a,e)',     () -> expect( Util.inArray( [1,2],1)       ).toBe(true) )
  it('atLength:(a,n)',    () -> expect( Util.atLength([1,2],2)       ).toBe(true) )
  it('head:(a)',          () -> expect( Util.head(    [1,2])         ).toEqual(1) )
  it('tail:(a)',          () -> expect( Util.tail(    [1,2])         ).toEqual(2) )
  it('isStrInteger:(s)',  () -> expect( Util.isStrInteger('1')       ).toBe(true) )
  it('isStrFloat:(s)',    () -> expect( Util.isStrFloat('1.0')       ).toBe(true) )
  it('isStrCurrency:(s)', () -> expect( Util.isStrCurrency('1.00')   ).toBe(true) )
  it('isDefs:(d)',         () -> expect( Util.isDefs( 1, 2 )         ).toBe(true) )
  it('indent',          () -> expect( Util.indent(2)                  ).toEqual('  ') )
  it("hashCode  stub", () -> expect( true                            ).toBe(true)  )
  it('lastTok',         () -> expect( Util.lastTok('1,2',',')         ).toEqual('2') )
  it('firstTok',        () -> expect( Util.firstTok('1,2',',')        ).toEqual('1') )

  it('quicksort',               () -> expect( Util.quicksort([2,3,1])).toEqual([1,2,3]) )
  it("isoDateTime:(date) stub", () -> expect( true ).toBe(true)  )
  it("toHMS:( unixTime ) stub", () -> expect( true ).toBe(true)  )
  it("@hex4:() stub",           () -> expect( true ).toBe(true)  )
  it("hex32:() stub",           () -> expect( true ).toBe(true)  )
  it("toFixed stub",            () -> expect( true ).toBe(true)  )
  it("toInt stub",              () -> expect( true ).toBe(true)  )
  it("toFloat stub",            () -> expect( true ).toBe(true)  )
  it("match stub",              () -> expect( true ).toBe(true)  )
  it("match_here",              () -> expect( true ).toBe(true)  )
  it("@match_star stub",        () -> expect( true ).toBe(true)  )
  it("match_test:(date) stub",  () -> expect( true ).toBe(true)  )
  it("match_args:(date) stub",  () -> expect( true ).toBe(true)  )

  it('parseURI',        () ->
    o = Util.parseURI( "http://example.com:3000/dir1/dir2/file.ext?search=test#hash" )
    expect( o.fileExt      ).toEqual(['file','ext'])
    expect( o.file         ).toEqual( 'file')
    expect( o.ext          ).toEqual( 'ext') )
)

describe("util/Util.coffee Load Modules Sttubbed", () ->
  it("verifyLoadModules stub", () -> expect( true                                ).toBe(true)  )
  it("loadInitLibs      stub", () -> expect( true                                ).toBe(true)  )
  it("loadModules       stub", () -> expect( true                                ).toBe(true)  )
  it("loadModule        stub", () -> expect( true                                ).toBe(true)  )
)

describe("util/Util.coffee UI Modules Sttubbed", () ->
  it("resize         stub", () -> expect( true                       ).toBe(true)  )
  it("resizeTimeout  stub", () -> expect( true                       ).toBe(true)  )
  it("extend         stub", () -> expect( true                       ).toBe(true)  )
  it("include        stub", () -> expect( true                       ).toBe(true)  )
  it("eventErrorCode stub", () -> expect( true                       ).toBe(true)  )
)

describe("util/Visual.cpffee", () ->
  it("resize         stub", () -> expect( true                       ).toBe(true)  )
  it("@rad:( deg ) -> deg * Math.PI / 180", () -> expect(true).toBe(true)  )
  it("@deg:( rad ) -> rad * 180 / Math.PI", () -> expect(true).toBe(true)  )
  it("@sin:( deg ) -> Math.sin(Visual.rad(deg))", () -> expect(true).toBe(true)  )
  it("@cos:( deg ) -> Math.cos(Visual.rad(deg))", () -> expect(true).toBe(true)  )
  it("@svgDeg:( deg ) -> 360-deg", () -> expect(true).toBe(true)  )
  it("@svgRad:( rad ) -> 2*Math.PI-rad", () -> expect(true).toBe(true)  )
  it("@radSvg:( deg ) -> Visual.rad(360-deg)", () -> expect(true).toBe(true)  )
  it("@degSvg:( rad ) -> Visual.deg(2*Math.PI-rad)", () -> expect(true).toBe(true)  )
  it("@sinSvg:( deg ) -> Math.sin(Visual.radSvg(deg))", () -> expect(true).toBe(true)  )
  it("@cosSvg:( deg ) -> Math.cos(Visual.radSvg(deg))", () -> expect(true).toBe(true)  )
  it("@pad2:( n  ) ->", () -> expect(true).toBe(true)  )
  it("@pad3:( n ) ->", () -> expect(true).toBe(true)  )
  it("@dec:( f )      -> ", () -> expect(true).toBe(true)  )
  it("@quotes:( str ) -> ", () -> expect(true).toBe(true)  )
  it("@within:( beg, deg, end ) -> beg   <= deg and deg <= end # Closed interval with <=", () -> expect(true).toBe(true)  )
  it("@isZero:( v )             -> -0.01 <  v   and v   <  0.01", () -> expect(true).toBe(true)  )
  it("@floor:( x, dx ) ->  dr = Math.round(dx); Math.floor( x / dr ) * dr", () -> expect(true).toBe(true)  )
  it("@ceil:(  x, dx ) ->  dr = Math.round(dx); Math.ceil(  x / dr ) * dr", () -> expect(true).toBe(true)  )
  it("@to:( a, a1, a2, b1, b2 ) -> (a-a1) / (a2-a1) * (b2-b1) + b1  # Linear transforms that calculates b from a", () -> expect(true).toBe(true)  )
  it("@angle:( x, y ) ->", () -> expect(true).toBe(true)  )
  it("@angleSvg:( x, y ) -> Visual.angle( x, -y )", () -> expect(true).toBe(true)  )
  it("@minRgb:( rgb ) -> Math.min( rgb.r,  rgb.g,  rgb.b )", () -> expect(true).toBe(true)  )
  it("@maxRgb:( rgb ) -> Math.max( rgb.r,  rgb.g,  rgb.b )", () -> expect(true).toBe(true)  )
  it("@sumRgb:( rgb ) ->           rgb.r + rgb.g + rgb.b", () -> expect(true).toBe(true)  )
  it("@hexCss:( hex ) -> ", () -> expect(true).toBe(true)  )
  it("@rgbCss:( rgb ) -> ", () -> expect(true).toBe(true)  )
  it("@hslCss:( hsl ) -> ", () -> expect(true).toBe(true)  )
  it("@hsiCss:( hsi ) -> Visual.hslCss( Visual.rgbToHsl( Visual.hsiToRgb(hsi) ) )", () -> expect(true).toBe(true)  )
  it("@hsvCss:( hsv ) -> Visual.hslCss( Visual.rgbToHsl( Visual.hsvToRgb(hsv) ) )", () -> expect(true).toBe(true)  )
  it("@roundRgb:( rgb, f=1.0 ) -> { r:Math.round(rgb.r*f), g:Math.round(rgb.g*f), b:Math.round(rgb.b*f) }", () -> expect(true).toBe(true)  )
  it("@roundHsl:( hsl ) -> { h:Math.round(hsl.h), s:Visual.dec(hsl.s), l:Visual.dec(hsl.l)    }", () -> expect(true).toBe(true)  )
  it("@roundHsi:( hsi ) -> { h:Math.round(hsi.h), s:Visual.dec(hsi.s), i:Math.round(hsi.i) }", () -> expect(true).toBe(true)  )
  it("@roundHsv:( hsv ) -> { h:Math.round(hsv.h), s:Visual.dec(hsv.s), v:Visual.dec(hsv.v)    }", () -> expect(true).toBe(true)  )
  it("@fixedDec:( rgb ) -> { r:Visual.dec(rgb.r),    g:Visual.dec(rgb.g), b:Visual.dec(rgb.b)    }", () -> expect(true).toBe(true)  )
  it("@hexRgb:( hex ) -> Visual.roundRgb( { r:(hex & 0xFF0000) >> 16, g:(hex & 0x00FF00) >> 8, b:hex & 0x0000FF } )", () -> expect(true).toBe(true)  )
  it("@rgbHex:( rgb ) -> rgb.r * 4096 + rgb.g * 256 + rgb.b", () -> expect(true).toBe(true)  )
  it("@cssRgb:( str ) ->", () -> expect(true).toBe(true)  )
  it("@rgbToHsi:( rgb ) ->", () -> expect(true).toBe(true)  )
  it("@hsiToRgb:( hsi ) ->", () -> expect(true).toBe(true)  )
  it("@hsvToRgb:( hsv ) ->", () -> expect(true).toBe(true)  )
  it("@rgbToHsv:( rgb ) ->", () -> expect(true).toBe(true)  )
  it("@hslToRgb:( hsl ) ->", () -> expect(true).toBe(true)  )
  it("@hue2rgb:( p, q, t ) ->", () -> expect(true).toBe(true)  )
  it("@rgbsToHsl:( red, green, blue ) ->", () -> expect(true).toBe(true)  )
  it("@rgbToHsl:( rgb ) ->", () -> expect(true).toBe(true)  )
)

describe("util/Type.coffee", () ->
  it("@isType:( type )         ->", () -> expect(true).toBe(true)  )
  it("@toType:( decl )         ->", () -> expect(true).toBe(true)  )
  it("@typeJS:( type )         ->", () -> expect(true).toBe(true)  )
  it("@convert:( value, type ) ->", () -> expect(true).toBe(true)  )
  it("@align:(  type )         ->", () -> expect(true).toBe(true)  )
  it("@cell:( value, type )    ->", () -> expect(true).toBe(true)  )
  it("@toObjType:( obj )       ->", () -> expect(true).toBe(true)  )
  it("@toClass:( obj )         ->", () -> expect(true).toBe(true)  )
  it("@isoDateString:( date )  ->", () -> expect(true).toBe(true)  )
  it("@toFixed:( arg, dec )    ->", () -> expect(true).toBe(true)  )
)

describe("util/Pallettes.coffee", () ->
  it("@color:( nameHex )        ->", () -> expect(true).toBe(true)  )
  it("@colorName:( name )       ->", () -> expect(true).toBe(true)  )
  it("@colorHex:( hex )         ->", () -> expect(true).toBe(true)  )
  it("@hexdec:( name )          ->", () -> expect(true).toBe(true)  )
  it("@hex:( code )             ->", () -> expect(true).toBe(true)  )
  it("@hexGroup:( group, code ) ->", () -> expect(true).toBe(true)  )
  it("@hexes:( group, c )       ->", () -> expect(true).toBe(true)  )
)

describe("util/GeoJson.coffee", () ->
  it(" boundingBoxAroundPolyCoords:(coords)            -> ", () -> expect(true).toBe(true)  )
  it(" pnpoly:(x, y, coords)                           -> ", () -> expect(true).toBe(true)  )
  it(" lineStringsIntersect:(l1, l2)                   -> ", () -> expect(true).toBe(true)  )
  it(" pointInBoundingBox:(point, bounds)              -> ", () -> expect(true).toBe(true)  )
  it(" pointInPolygon:(p, poly)                        -> ", () -> expect(true).toBe(true)  )
  it(" pointInMultiPolygon:(p, poly)                   -> ", () -> expect(true).toBe(true)  )
  it(" numberToRadius:(number)                         -> ", () -> expect(true).toBe(true)  )
  it(" numberToDegree:(number)                         -> ", () -> expect(true).toBe(true)  )
  it(" drawCircle:(radiusInMeters, centerPoint, steps) -> ", () -> expect(true).toBe(true)  )
  it(" rectangleCentroid:(rectangle)                   -> ", () -> expect(true).toBe(true)  )
  it(" pointDistance:(pt1, pt2)                        -> ", () -> expect(true).toBe(true)  )
  it(" geometryWithinRadius:(geometry, center, radius) -> ", () -> expect(true).toBe(true)  )
  it(" area:(polygon)                                  -> ", () -> expect(true).toBe(true)  )
  it(" centroid:(polygon)                              -> ", () -> expect(true).toBe(true)  )
  it(" simplify:(source, kink)                         -> ", () -> expect(true).toBe(true)  )
  it(" destinationPoint:(pt, brng, dist)               -> ", () -> expect(true).toBe(true)  )
)