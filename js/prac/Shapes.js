// Generated by CoffeeScript 1.12.2
(function() {
  var Prac, Shapes, UI, Vis, d3,
    hasProp = {}.hasOwnProperty;

  d3 = require('d3');

  Vis = require('js/util/Vis');

  UI = require('js/ui/UI');

  Prac = require('js/prac/Prac');

  Shapes = (function() {
    module.exports = Shapes;

    Prac.Shapes = Shapes;

    function Shapes(stream, prac) {
      this.stream = stream;
      this.prac = prac;
    }

    Shapes.prototype.ready = function() {};

    Shapes.prototype.isWest = function(column) {
      return column === 'Embrace';
    };

    Shapes.prototype.layout = function(geom, column, ns, ni) {
      var lay;
      lay = {};
      lay.dir = this.isWest(column) ? 1 : -1;
      lay.xc = geom.x0;
      lay.yc = geom.y0;
      lay.w = geom.wp;
      lay.h = geom.hp;
      lay.hk = lay.h / 8;
      lay.xk = this.isWest(column) ? lay.w : 0;
      lay.yk = lay.yc - lay.hk;
      lay.rs = lay.yc * 0.85;
      lay.ro = lay.rs - lay.hk;
      lay.ri = lay.ro - lay.hk / 4;
      lay.yt = lay.yc + lay.ro + lay.rs * 0.65;
      lay.a1 = this.isWest(column) ? 60 : 120;
      lay.a2 = this.isWest(column) ? 300 : -120;
      lay.ns = ns;
      lay.da = (lay.a1 - lay.a2) / lay.ns;
      lay.ds = lay.da / 12;
      lay.li = lay.ds / 2;
      lay.wr = 8;
      lay.hr = lay.ri / lay.ns;
      lay.xr = lay.xc + lay.dir * (lay.rs / 2 + lay.wr);
      lay.yr = lay.yc - lay.ri / 2;
      lay.dl = lay.hr / 12;
      lay.xl = lay.xr + lay.wr;
      lay.yl = lay.yr + lay.dl / 2;
      lay.ni = ni;
      lay.xi = 0;
      lay.yi = lay.yc - lay.ri / 2;
      lay.wi = lay.wr;
      lay.hi = lay.ri / lay.ni;
      lay.thick = 1;
      lay.stroke = 'none';
      return lay;
    };

    Shapes.prototype.click = function(path, text) {
      path.style('z-index', '4');
      path.on("click", (function(_this) {
        return function() {
          var select;
          select = UI.Build.select(Util.toSelect(text), 'Shapes', UI.Build.SelectStudy);
          return _this.stream.publish('Select', select);
        };
      })(this));
    };

    Shapes.prototype.wedge = function(g, r1, r2, a1, a2, x0, y0, fill, text, wedgeId) {
      var arc;
      arc = d3.arc().innerRadius(r1).outerRadius(r2).startAngle(this.radD3(a1)).endAngle(this.radD3(a2));
      g.append("svg:path").attr("d", arc).attr("fill", fill).attr("stroke", "none").attr("transform", "translate(" + x0 + "," + y0 + ")");
      this.wedgeText(g, r1, r2, a1, a2, x0, y0, fill, text, wedgeId);
    };

    Shapes.prototype.wedgeText = function(g, r1, r2, a1, a2, x0, y0, fill, text, wedgeId) {
      var as, at, path, rt, th, x, y;
      th = 14;
      at = (a1 + a2) / 2;
      if ((210 <= at && at <= 330) || (-150 <= at && at <= -30)) {
        rt = (r1 + r2) / 2 + th * 0.25;
        as = 270 - at;
      } else {
        rt = (r1 + r2) / 2 - th * 0.5;
        as = 90 - at;
      }
      x = x0 + rt * Prac.cos(at);
      y = y0 + rt * Prac.sin(at);
      path = g.append("svg:text").text(text).attr("x", x).attr("y", y).attr("transform", "rotate(" + as + " " + x + " " + y + ")").attr("text-anchor", "middle").attr("font-size", th + "px").attr("font-family", "FontAwesome").attr('fill', '#000000');
      this.click(path, text);
    };

    Shapes.prototype.icon = function(g, x0, y0, name, iconId, uc) {
      var path;
      path = g.append("svg:text").text(uc).attr("x", x0).attr("y", y0 + 12).attr("id", iconId).attr("text-anchor", "middle").attr("font-size", "2em").attr("font-family", "FontAwesome");
      this.click(path, name);
    };

    Shapes.prototype.text = function(g, x0, y0, name, textId, color) {
      var path;
      path = g.append("svg:text").text(name).attr("x", x0).attr("y", y0).attr("id", textId).attr("fill", color).attr("text-anchor", "middle").attr("font-size", "1.4em").attr("font-family", "FontAwesome");
      this.click(path, name);
    };

    Shapes.prototype.link = function(g, a, ra, rb, xc, yc, xd, yd, xe, ye, stroke, thick) {
      var data, xa, xb, ya, yb;
      xa = xc + ra * Prac.cos(a);
      ya = yc + ra * Prac.sin(a);
      xb = xc + rb * Prac.cos(a);
      yb = yc + rb * Prac.sin(a);
      data = "M" + xa + "," + ya + " C" + xb + "," + yb + " " + xd + "," + yd + " " + xe + "," + ye;
      this.curve(g, data, stroke, thick);
    };

    Shapes.prototype.curve = function(g, data, stroke, thick) {
      g.append("svg:path").attr("d", data).attr("stroke-linejoin", "round").attr("fill", "none").attr("stroke", stroke).attr("stroke-width", thick);
    };

    Shapes.prototype.keyHole = function(g, xc, yc, xs, ys, ro, ri, fill, stroke, thick) {
      var a, data, h, isweep, osweep, rh, rx;
      if (stroke == null) {
        stroke = 'none';
      }
      if (thick == null) {
        thick = 0;
      }
      h = yc - ys;
      a = Math.asin(h / ro);
      rx = Math.cos(a) * ro;
      rh = ri;
      osweep = 0;
      isweep = 1;
      if (xs < xc) {
        rx = -rx;
        rh = -ri;
        osweep = 1;
        isweep = 0;
      }
      data = "M" + xs + ",   " + ys;
      data += "L" + (xc + rx) + "," + ys + " A" + ro + "," + ro + " 0, 1," + osweep + " " + (xc + rx) + "," + (yc + h);
      data += "L" + xs + ",   " + (yc + h) + " L" + xs + "," + ys;
      data += "M" + (xc + rh) + "," + yc + " A" + ri + "," + ri + " 0, 1," + isweep + " " + (xc + rh) + "," + (yc - 0.001);
      this.poly(g, data, fill, stroke, thick);
    };

    Shapes.prototype.poly = function(g, data, fill) {
      g.append("svg:path").attr("d", data).attr("stroke-linejoin", "round").attr("fill", fill);
    };

    Shapes.prototype.rect = function(g, x0, y0, w, h, fill, stroke, text, ts) {
      if (text == null) {
        text = '';
      }
      if (ts == null) {
        ts = 1.0;
      }
      g.append("svg:rect").attr("x", x0).attr("y", y0).attr("width", w).attr("height", h).attr("fill", fill).attr("stroke", stroke);
      if (text !== '') {
        g.append("svg:text").text(text).attr("x", x0 + w / 2).attr("y", y0 + h / 2 + 14).attr('fill', 'black').attr("text-anchor", "middle").attr("font-size", (ts * 1.2) + "em").attr("font-family", "FontAwesome");
      }
    };

    Shapes.prototype.round = function(g, x0, y0, w, h, rx, ry, fill, stroke) {
      g.append("svg:rect").attr("x", x0).attr("y", y0).attr("width", w).attr("height", h).attr("rx", rx).attr("ry", ry).attr("fill", fill).attr("stroke", stroke);
    };

    Shapes.prototype.elipse = function(g, cx, cy, rx, ry, fill, stroke) {
      g.append("svg:ellipse").attr("cx", cx).attr("cy", cy).attr("rx", rx).attr("ry", ry).attr("fill", fill).attr("stroke", stroke);
    };

    Shapes.prototype.circle = function(g, cx, cy, r, fill, stroke) {
      g.append("svg:ellipse").attr("cx", cx).attr("cy", cy).attr("r", r).attr("fill", fill).attr("stroke", stroke);
    };

    Shapes.prototype.pathPlot = function(g, stroke, thick, d) {
      g.append('svg:path').attr('d', d).attr('stroke', stroke).attr('stroke-width', thick).attr('fill', 'none').attr("stroke-linejoin", 'round');
    };

    Shapes.prototype.embraceSankeyNodesLinks = function(studies, innovs) {
      var iKey, innov, key, links, nodes, sKey, study;
      nodes = [];
      for (key in studies) {
        if (!hasProp.call(studies, key)) continue;
        study = studies[key];
        nodes.push({
          name: key,
          color: this.prac.toFill(study)
        });
      }
      for (key in innovs) {
        if (!hasProp.call(innovs, key)) continue;
        innov = innovs[key];
        nodes.push({
          name: key,
          color: this.prac.toFill(innov)
        });
      }
      links = [];
      for (sKey in studies) {
        if (!hasProp.call(studies, sKey)) continue;
        study = studies[sKey];
        for (iKey in innovs) {
          if (!hasProp.call(innovs, iKey)) continue;
          innov = innovs[iKey];
          links.push({
            source: sKey,
            target: iKey,
            value: 1
          });
        }
      }
      return {
        nodes: nodes,
        links: links
      };
    };

    Shapes.prototype.encourageSankeyNodesLinks = function(studies, innovs) {
      var iKey, innov, key, links, nodes, sKey, study;
      nodes = [];
      for (key in innovs) {
        if (!hasProp.call(innovs, key)) continue;
        innov = innovs[key];
        nodes.push({
          name: key,
          color: this.prac.toFill(innov)
        });
      }
      for (key in studies) {
        if (!hasProp.call(studies, key)) continue;
        study = studies[key];
        nodes.push({
          name: key,
          color: this.prac.toFill(study)
        });
      }
      links = [];
      for (iKey in innovs) {
        if (!hasProp.call(innovs, iKey)) continue;
        innov = innovs[iKey];
        for (sKey in studies) {
          if (!hasProp.call(studies, sKey)) continue;
          study = studies[sKey];
          links.push({
            source: iKey,
            target: sKey,
            value: 1
          });
        }
      }
      return {
        nodes: nodes,
        links: links
      };
    };

    Shapes.prototype.conveySankey = function(embrace, defs, g, studies, innovs, x, y, w, h, nodeWidth, nodePadding) {
      var Sankey, nodesLinks, sankey;
      Sankey = require('js/d3d/Sankey');
      sankey = new Sankey(defs, g, x, y, w, h, nodeWidth, nodePadding, false);
      nodesLinks = {};
      if (embrace) {
        nodesLinks = this.embraceSankeyNodesLinks(studies, innovs);
      } else {
        nodesLinks = this.encourageSankeyNodesLinks(studies, innovs);
      }
      sankey.doData(nodesLinks);
    };

    Shapes.prototype.practiceFlow = function(g, geom, spec) {
      if (spec.row == null) {
        return;
      }
      switch (spec.row) {
        case 'Learn':
          this.flow(g, geom, [90, 90, 90], 'South');
          break;
        case 'Do':
          this.flow(g, geom, [90, 90, 90], 'North');
          this.flow(g, geom, [60, 90, 90], 'South');
          break;
        case 'Share':
          this.flow(g, geom, [60, 90, 90], 'North');
          break;
        default:
          Util.error(' unknown spec row ', spec.name, spec.row);
          this.flow(g, geom, [90, 90, 90], 'South');
      }
    };

    Shapes.prototype.flow = function(g, geom, hsv, dir) {
      var fill, h, w, x0, y0;
      w = 18;
      h = 24;
      x0 = geom.x0 - w / 2;
      y0 = dir === 'South' ? geom.h - h : 0;
      fill = Vis.toRgbHsvStr(hsv);
      this.rect(g, x0, y0, w, h, fill, 'none');
    };

    Shapes.prototype.rad = function(deg) {
      return (360 - deg) * Math.PI / 180.0;
    };

    Shapes.prototype.degSVG = function(deg) {
      return 360 - deg;
    };

    Shapes.prototype.radD3 = function(deg) {
      return (450 - deg) * Math.PI / 180.0;
    };

    Shapes.prototype.degD3 = function(rad) {
      return -rad * 180.0 / Math.PI;
    };

    Shapes.prototype.cos = function(deg) {
      return Vis.cosSvg(deg);
    };

    Shapes.prototype.sin = function(deg) {
      return Vis.sinSvg(deg);
    };

    Shapes.prototype.textFill = function(hex, dark, light) {
      if (dark == null) {
        dark = '#000000';
      }
      if (light == null) {
        light = '#FFFFFF';
      }
      if (hex > 0x888888) {
        return dark;
      } else {
        return light;
      }
    };

    Shapes.prototype.textFill1 = function(fill, dark, light) {
      if (dark == null) {
        dark = '#000000';
      }
      if (light == null) {
        light = '#FFFFFF';
      }
      if ((fill != null) && Vis.Palettes.hex(fill) > 0xffffff / 2) {
        return dark;
      } else {
        return light;
      }
    };

    return Shapes;

  })();

}).call(this);
