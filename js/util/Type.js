// Generated by CoffeeScript 1.10.0
(function() {
  var Type,
    hasProp = {}.hasOwnProperty;

  Type = (function() {
    function Type() {}

    module.exports = Type;

    Type.typesJS = ['number', 'string', 'boolean', 'object', 'function', 'undefined', 'null'];

    Type.typesJA = ['n', 's', 'b', 'o', 'f', 'u', 'q'];

    Type.typesAx = ['Array', 'Id', 'Int', 'Float', 'Currency', 'Date', 'Enum', 'Extend'];

    Type.typesAA = ['A', 'P', 'I', 'F', '$', 'D', 'E', 'X'];

    Type.types = Type.typesJS.concat(Type.typesAx);

    Type.typesa = Type.typesJA.concat(Type.typesAA);

    Type.Opts = ['?', '1', '*', '+'];

    Type.cssUOM = ['px', 'in', 'cm', 'mm', 'pc', 'pt', 'px', 'em', 'ex', 'ch', 'vb', 'vw', 'vmax', 'vmin'];

    Type.siUOM = ['m', 'kg', 's', 'A', 'K', 'mol', 'cd'];

    Type.axUOM = ['deg', 'rad', 'colorname', 'hex', 'rgb', 'rgba', 'hsl', 'hsla'];

    Type.UOMs = Type.cssUOM.concat(Type.siUOM, Type.axUOM);

    Type.Props = {
      'name': 'name',
      'type': 'type',
      'schema': 'schema',
      'enum': 'enum',
      'range': 'range',
      'minmax': 'minmax',
      'validator': 'validator',
      'format': 'format',
      'default': 'default',
      'uom': 'uom',
      'abstract': 'abstract',
      'width': 'width'
    };

    Type.Propa = {
      'n': 'n',
      't': 't',
      's': 's',
      'e': 'e',
      'r': 'r',
      'm': 'm',
      'v': 'v',
      'f': 'f',
      'd': 'd',
      'u': 'u',
      'a': 'a',
      'w': 'w'
    };

    Type.isType = function(type) {
      return Util.contains(Type.types, type) || Util.contains(Type.typesa, type);
    };

    Type.toType = function(decl) {
      var index;
      index = Schema.typesa.indexOf(decl);
      if (index >= 0) {
        return Type.types[index];
      } else {
        return 'null';
      }
    };

    Type.isProp = function(key) {
      return Util.contains(Type.Props, key) || Util.contains(Type.Propa, key);
    };

    Type.toProp = function(chr) {
      var index;
      index = Schema.Propa.indexOf(chr);
      if (index >= 0) {
        return Schema.Props[index];
      } else {
        return 'null';
      }
    };

    Type.isUOM = function(uom) {
      return Util.contains(Schema.UOMs, uom);
    };

    Type.isOpt = function(opt) {
      return Util.contains(Schema.Opts, opt);
    };

    Util.Check = {};

    Type.checkStart = function(model, schema, name) {
      Type.checkModel(model, schema, Util.Check, name);
      Util.schema = schema;
      return Util.Check[name];
    };

    Type.checkModel = function(model, schema, check, key) {
      var report;
      report = {};
      if (Util.isArray(model)) {
        Type.checkArray(model, schema, report, key);
      } else if (Util.isObj(model)) {
        Type.checkObject(model, schema, report, key);
      } else if (Util.isVal(model)) {
        Type.checkValue(model, schema, report, key);
      } else {
        report['error'] = {
          error: "Unknown model type " + (typeof model)
        };
      }
      check[key] = report;
    };

    Type.checkArray = function(array, schema, check, keyObj) {
      var branch, i, j, ref;
      check['range'] = Type.checkRange(array, schema);
      for (i = j = 0, ref = array.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        branch = Type.branchSchema(schema, keyObj);
        Type.checkModel(array[i], branch, check, i.toString());
      }
    };

    Type.checkObject = function(object, schema, check, keyObj) {
      var keyVal, schemaKey, schemaObj, val;
      schemaObj = Type.branchSchema(schema, keyObj);
      Type.checkProps(object, schemaObj, check, keyObj);
      for (keyVal in object) {
        if (!hasProp.call(object, keyVal)) continue;
        val = object[keyVal];
        schemaKey = Type.branchSchema(schemaObj, keyObj, keyVal);
        Type.checkModel(val, schemaKey, check, keyVal);
        if (!schemaObj[keyVal]) {
          check[keyVal] = {};
          check[keyVal]['extra'] = true;
        }
      }
    };

    Type.checkValue = function(value, schema, check, key) {
      check['value'] = value;
      check['types'] = schema.type;
      check['match'] = typeof value === Type.typeJS(schema.type);
      if (schema.Enum != null) {
        check['enums'] = Util.contains(schema.Enum, value);
      }
    };

    Type.checkProps = function(object, schema, check, keyObj) {
      var branch, prop, results, spec;
      branch = Type.branchSchema(schema, keyObj);
      results = [];
      for (prop in branch) {
        if (!hasProp.call(branch, prop)) continue;
        spec = branch[prop];
        if ((object[prop] == null) && Type.isRequired(spec.range)) {
          check[prop] = {};
          check[prop]['exist'] = false;
          if (spec.range != null) {
            results.push(check[prop]['specs'] = spec.range);
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Type.isNotOk = function(report) {
      var status;
      status = true;
      if (report['range'] != null) {
        status &= report['range'];
      }
      if (report['exist'] != null) {
        status &= report['exist'];
      }
      if (report['match'] != null) {
        status &= report['match'];
      }
      if (report['enums'] != null) {
        status &= report['enums'];
      }
      status &= report['error'] == null;
      return status;
    };

    Type.branchSchema = function(schema, keyObj, keyVal) {
      if (keyVal == null) {
        keyVal = null;
      }
      if (schema.schema != null) {
        return schema.schema;
      } else if ((keyVal != null) && (schema[keyVal] != null)) {
        return schema[keyVal];
      } else if (schema[keyObj] != null) {
        return schema[keyObj];
      } else {
        return schema;
      }
    };

    Type.checkRange = function(array, schema) {
      var n;
      n = array.length;
      if (schema.minmax != null) {
        return schema.minmax[0] <= n && n <= schema.minmax[1];
      } else if (Type.isRequired(schema.range)) {
        return n > 0;
      } else if (Type.notRequired(schema.range)) {
        return n >= 0;
      }
    };

    Type.isRequired = function(range) {
      return (range == null) || range === '1' || range === '+';
    };

    Type.notRequired = function(range) {
      return (range != null) && (range === '?' || range === '*');
    };

    Type.typeJS = function(type) {
      switch (type) {
        case 'number':
        case 'Int':
        case 'Float':
        case 'Currency':
          return 'number';
        case 'string':
        case 'Date':
        case 'Id':
        case 'Enum':
          return 'string';
        case 'boolean':
          return 'boolean';
        case 'object':
        case 'Array':
          return 'object';
        case 'function':
          return 'function';
        case 'undefined':
          return 'undefined';
        case 'null':
          return 'null';
        default:
          return 'undefined';
      }
    };

    Type.toValue = function(str, type) {
      switch (type) {
        case 'number':
        case 'Int':
          return parseInt(str);
        case 'Float':
        case 'Currency':
          return parseFloat(str);
        case 'Date':
        case 'Time':
          return Date.parse(str);
        default:
          return str;
      }
    };

    Type.align = function(type) {
      switch (type) {
        case 'number':
        case 'Int':
        case 'Float':
        case 'Currency':
          return 'right';
        case 'string':
        case 'Date':
        case 'Id':
        case 'Enum':
          return 'left';
        case 'boolean':
          return 'center';
        case 'object':
        case 'Array':
          return 'left';
        case 'function':
          return 'left';
        case 'undefined':
        case 'null':
          return 'left';
        default:
          return 'center';
      }
    };

    Type.cell = function(value, type) {
      switch (type) {
        case 'number':
        case 'Int':
          return value;
        case 'Float':
        case 'Currency':
          return Util.toFixed(value, 2);
        case 'string':
        case 'Date':
        case 'Id':
        case 'Enum':
          return value;
        case 'boolean':
          return value;
        case 'object':
          return value;
        case 'Array':
          return "[" + (value.join(',')) + "]";
        case 'function':
          return "function";
        case 'undefined':
        case 'null':
          return '';
        default:
          return value;
      }
    };

    Type.toObjType = function(obj) {
      return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
    };

    Type.toClass = function(obj) {
      if (obj.constructor != null) {
        return obj.constructor.name;
      } else {
        return 'null';
      }
    };

    Type.isoDateString = function(date) {
      var pad;
      pad = function(n) {
        if (n < 10) {
          return '0' + n;
        } else {
          return n;
        }
      };
      return date.getUTCFullYear()(+'-' + pad(date.getUTCMonth() + 1) + '-' + pad(date.getUTCDate()) + 'T' + pad(date.getUTCHours()) + ':' + pad(date.getUTCMinutes()) + ':' + pad(date.getUTCSeconds()) + 'Z');
    };

    Type.toFixed = function(arg, dec) {
      var num;
      num = (function() {
        switch (typeof arg) {
          case 'number':
            return arg;
          case 'string':
            return parseFloat(arg);
          default:
            return 0;
        }
      })();
      return num.toFixed(dec);
    };


    /*
      where = () -> true
      model = Util.toObjects( model, where, schema.aaa.key )
      Type.checkObject( model, schema, check, key )
     */

    return Type;

  })();

}).call(this);
