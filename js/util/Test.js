// Generated by CoffeeScript 1.10.0
(function() {
  var Stream, Test;

  window.xUtil.fixTestGlobals();

  Stream = require('js/util/Stream');

  beforeAll(function() {
    var stream;
    stream = new Stream();
    Util.noop(stream);
    return this.test = new Test();
  });

  Test = (function() {
    Test.toStrArgs = function() {
      return Util.toStrArgs('Test:', arguments);
    };

    function Test() {
      this.obj = {};
      this.obj.method = function() {
        return 'Hi';
      };
    }

    return Test;

  })();

  describe("util/Util.coffee", function() {

    /*
    it("hasMethod",              () -> expect( Util.hasMethod(  @test.obj, 'method'    ) ).toBe(true)  )
    it("hasGlobal",              () -> expect( Util.hasGlobal( 'Util'            ) ).toBe(true)  )
    it("hasGlobal",              () -> expect( Util.getGlobal( 'fullScreen'      ) ).toBe(false) )
    it("hasPlugin",              () -> expect( Util.hasPlugin( 'Util.hasPlugin'  ) ).toBe(true)  )
    it("hasModule",              () -> expect( Util.hasModule( 'util/Util'       ) ).toBe(true)  )
    it("dependsOn(global)",      () -> expect( Util.dependsOn( 'jasmine'         ) ).toBe(true)  )
    it("dependsOn(module)",      () -> expect( Util.dependsOn( 'util/Util'       ) ).toBe(true)  )
    it("dependsOn(plugin)",      () -> expect( Util.dependsOn( 'Util.hasPlugin'  ) ).toBe(true)  )
    it("Export Import",          () -> # Util.Export(   Util,'zzz/Util'); expect(true).toBe( require(    'js/util/Util').testTrue ) )
    it("setModule   getModule",  () -> Util.setModule(Util,'yyy/Util'); expect(true).toBe( Util.getModule('js/util/Util').testTrue ) )
    it("setInstance getInstance",() -> Util.setInstance('xx','xx');      expect('xx').toEqual( Util.getInstance('xx') ) )
     */
    it("toStr", function() {
      return expect(Util.toStr(null)).toEqual('null');
    });
    it("toStr", function() {
      return expect(Util.toStr('1')).toEqual('1');
    });
    it("toStr", function() {
      return expect(Util.toStr(1)).toEqual('1');
    });
    it("toStr", function() {
      return expect(Util.toStr(1.0)).toEqual('1');
    });
    it("toStr", function() {
      return expect(Util.toStr({
        a: 1,
        b: 2
      })).toEqual('{ a:1, b:2 }');
    });
    it("toStrStr", function() {
      return expect(Util.toStrStr('str')).toEqual('str');
    });
    it("toStrStr", function() {
      return expect(Util.toStrStr('')).toEqual('""');
    });
    it("toStrArgs", function() {
      return expect(Test.toStrArgs('a', 1, {
        a: 1,
        b: 2
      })).toEqual('Test: a 1 { a:1, b:2 } ');
    });
    it("toStrObj", function() {
      return expect(Util.toStrObj({
        a: 1,
        b: 2
      })).toEqual('{ a:1, b:2 }');
    });
    it('isDef:(d)', function() {
      return expect(Util.isDef(Util.testTrue)).toBe(true);
    });
    it('isStr:(s)', function() {
      return expect(Util.isStr('1')).toBe(true);
    });
    it('isNum:(n)', function() {
      return expect(Util.isNum(1)).toBe(true);
    });
    it('isObj:(o)', function() {
      return expect(Util.isObj({
        a: 1,
        b: 2
      })).toBe(true);
    });
    it('isObjEmpty:(o)', function() {
      return expect(Util.isObjEmpty({})).toBe(true);
    });
    it('isFunc:(f)', function() {
      return expect(Util.isFunc(Util.isFunc)).toBe(true);
    });
    it('isArray:(a)', function() {
      return expect(Util.isArray([1, 2])).toBe(true);
    });
    it('isEvent:(e)', function() {
      return expect(Util.isEvent({
        target: 1
      })).toBe(true);
    });
    it('inIndex:(a,i)', function() {
      return expect(Util.inIndex([1, 2], 1)).toBe(true);
    });
    it('inArray:(a,e)', function() {
      return expect(Util.inArray([1, 2], 1)).toBe(true);
    });
    it('atLength:(a,n)', function() {
      return expect(Util.atLength([1, 2], 2)).toBe(true);
    });
    it('head:(a)', function() {
      return expect(Util.head([1, 2])).toEqual(1);
    });
    it('tail:(a)', function() {
      return expect(Util.tail([1, 2])).toEqual(2);
    });
    it('isStrInteger:(s)', function() {
      return expect(Util.isStrInteger('1')).toBe(true);
    });
    it('isStrFloat:(s)', function() {
      return expect(Util.isStrFloat('1.0')).toBe(true);
    });
    it('isStrCurrency:(s)', function() {
      return expect(Util.isStrCurrency('1.00')).toBe(true);
    });
    it('isDefs:(d)', function() {
      return expect(Util.isDefs(1, 2)).toBe(true);
    });
    it('indent', function() {
      return expect(Util.indent(2)).toEqual('  ');
    });
    it("hashCode  stub", function() {
      return expect(true).toBe(true);
    });
    it('lastTok', function() {
      return expect(Util.lastTok('1,2', ',')).toEqual('2');
    });
    it('firstTok', function() {
      return expect(Util.firstTok('1,2', ',')).toEqual('1');
    });
    it('quicksort', function() {
      return expect(Util.quicksort([2, 3, 1])).toEqual([1, 2, 3]);
    });
    it("isoDateTime:(date) stub", function() {
      return expect(true).toBe(true);
    });
    it("toHMS:( unixTime ) stub", function() {
      return expect(true).toBe(true);
    });
    it("@hex4:() stub", function() {
      return expect(true).toBe(true);
    });
    it("hex32:() stub", function() {
      return expect(true).toBe(true);
    });
    it("toFixed stub", function() {
      return expect(true).toBe(true);
    });
    it("toInt stub", function() {
      return expect(true).toBe(true);
    });
    it("toFloat stub", function() {
      return expect(true).toBe(true);
    });
    it("match stub", function() {
      return expect(true).toBe(true);
    });
    it("match_here", function() {
      return expect(true).toBe(true);
    });
    it("@match_star stub", function() {
      return expect(true).toBe(true);
    });
    it("match_test:(date) stub", function() {
      return expect(true).toBe(true);
    });
    it("match_args:(date) stub", function() {
      return expect(true).toBe(true);
    });
    return it('parseURI', function() {
      var o;
      o = Util.parseURI("http://example.com:3000/dir1/dir2/file.ext?search=test#hash");
      expect(o.fileExt).toEqual(['file', 'ext']);
      expect(o.file).toEqual('file');
      return expect(o.ext).toEqual('ext');
    });
  });

  describe("util/Util.coffee Load Modules Sttubbed", function() {
    it("verifyLoadModules stub", function() {
      return expect(true).toBe(true);
    });
    it("loadInitLibs      stub", function() {
      return expect(true).toBe(true);
    });
    it("loadModules       stub", function() {
      return expect(true).toBe(true);
    });
    return it("loadModule        stub", function() {
      return expect(true).toBe(true);
    });
  });

  describe("util/Util.coffee UI Modules Sttubbed", function() {
    it("resize         stub", function() {
      return expect(true).toBe(true);
    });
    it("resizeTimeout  stub", function() {
      return expect(true).toBe(true);
    });
    it("extend         stub", function() {
      return expect(true).toBe(true);
    });
    it("include        stub", function() {
      return expect(true).toBe(true);
    });
    return it("eventErrorCode stub", function() {
      return expect(true).toBe(true);
    });
  });

  describe("util/Visual.cpffee", function() {
    it("resize         stub", function() {
      return expect(true).toBe(true);
    });
    it("@rad:( deg ) -> deg * Math.PI / 180", function() {
      return expect(true).toBe(true);
    });
    it("@deg:( rad ) -> rad * 180 / Math.PI", function() {
      return expect(true).toBe(true);
    });
    it("@sin:( deg ) -> Math.sin(Visual.rad(deg))", function() {
      return expect(true).toBe(true);
    });
    it("@cos:( deg ) -> Math.cos(Visual.rad(deg))", function() {
      return expect(true).toBe(true);
    });
    it("@svgDeg:( deg ) -> 360-deg", function() {
      return expect(true).toBe(true);
    });
    it("@svgRad:( rad ) -> 2*Math.PI-rad", function() {
      return expect(true).toBe(true);
    });
    it("@radSvg:( deg ) -> Visual.rad(360-deg)", function() {
      return expect(true).toBe(true);
    });
    it("@degSvg:( rad ) -> Visual.deg(2*Math.PI-rad)", function() {
      return expect(true).toBe(true);
    });
    it("@sinSvg:( deg ) -> Math.sin(Visual.radSvg(deg))", function() {
      return expect(true).toBe(true);
    });
    it("@cosSvg:( deg ) -> Math.cos(Visual.radSvg(deg))", function() {
      return expect(true).toBe(true);
    });
    it("@pad2:( n  ) ->", function() {
      return expect(true).toBe(true);
    });
    it("@pad3:( n ) ->", function() {
      return expect(true).toBe(true);
    });
    it("@dec:( f )      -> ", function() {
      return expect(true).toBe(true);
    });
    it("@quotes:( str ) -> ", function() {
      return expect(true).toBe(true);
    });
    it("@within:( beg, deg, end ) -> beg   <= deg and deg <= end # Closed interval with <=", function() {
      return expect(true).toBe(true);
    });
    it("@isZero:( v )             -> -0.01 <  v   and v   <  0.01", function() {
      return expect(true).toBe(true);
    });
    it("@floor:( x, dx ) ->  dr = Math.round(dx); Math.floor( x / dr ) * dr", function() {
      return expect(true).toBe(true);
    });
    it("@ceil:(  x, dx ) ->  dr = Math.round(dx); Math.ceil(  x / dr ) * dr", function() {
      return expect(true).toBe(true);
    });
    it("@to:( a, a1, a2, b1, b2 ) -> (a-a1) / (a2-a1) * (b2-b1) + b1  # Linear transforms that calculates b from a", function() {
      return expect(true).toBe(true);
    });
    it("@angle:( x, y ) ->", function() {
      return expect(true).toBe(true);
    });
    it("@angleSvg:( x, y ) -> Visual.angle( x, -y )", function() {
      return expect(true).toBe(true);
    });
    it("@minRgb:( rgb ) -> Math.min( rgb.r,  rgb.g,  rgb.b )", function() {
      return expect(true).toBe(true);
    });
    it("@maxRgb:( rgb ) -> Math.max( rgb.r,  rgb.g,  rgb.b )", function() {
      return expect(true).toBe(true);
    });
    it("@sumRgb:( rgb ) ->           rgb.r + rgb.g + rgb.b", function() {
      return expect(true).toBe(true);
    });
    it("@hexCss:( hex ) -> ", function() {
      return expect(true).toBe(true);
    });
    it("@rgbCss:( rgb ) -> ", function() {
      return expect(true).toBe(true);
    });
    it("@hslCss:( hsl ) -> ", function() {
      return expect(true).toBe(true);
    });
    it("@hsiCss:( hsi ) -> Visual.hslCss( Visual.rgbToHsl( Visual.hsiToRgb(hsi) ) )", function() {
      return expect(true).toBe(true);
    });
    it("@hsvCss:( hsv ) -> Visual.hslCss( Visual.rgbToHsl( Visual.hsvToRgb(hsv) ) )", function() {
      return expect(true).toBe(true);
    });
    it("@roundRgb:( rgb, f=1.0 ) -> { r:Math.round(rgb.r*f), g:Math.round(rgb.g*f), b:Math.round(rgb.b*f) }", function() {
      return expect(true).toBe(true);
    });
    it("@roundHsl:( hsl ) -> { h:Math.round(hsl.h), s:Visual.dec(hsl.s), l:Visual.dec(hsl.l)    }", function() {
      return expect(true).toBe(true);
    });
    it("@roundHsi:( hsi ) -> { h:Math.round(hsi.h), s:Visual.dec(hsi.s), i:Math.round(hsi.i) }", function() {
      return expect(true).toBe(true);
    });
    it("@roundHsv:( hsv ) -> { h:Math.round(hsv.h), s:Visual.dec(hsv.s), v:Visual.dec(hsv.v)    }", function() {
      return expect(true).toBe(true);
    });
    it("@fixedDec:( rgb ) -> { r:Visual.dec(rgb.r),    g:Visual.dec(rgb.g), b:Visual.dec(rgb.b)    }", function() {
      return expect(true).toBe(true);
    });
    it("@hexRgb:( hex ) -> Visual.roundRgb( { r:(hex & 0xFF0000) >> 16, g:(hex & 0x00FF00) >> 8, b:hex & 0x0000FF } )", function() {
      return expect(true).toBe(true);
    });
    it("@rgbHex:( rgb ) -> rgb.r * 4096 + rgb.g * 256 + rgb.b", function() {
      return expect(true).toBe(true);
    });
    it("@cssRgb:( str ) ->", function() {
      return expect(true).toBe(true);
    });
    it("@rgbToHsi:( rgb ) ->", function() {
      return expect(true).toBe(true);
    });
    it("@hsiToRgb:( hsi ) ->", function() {
      return expect(true).toBe(true);
    });
    it("@hsvToRgb:( hsv ) ->", function() {
      return expect(true).toBe(true);
    });
    it("@rgbToHsv:( rgb ) ->", function() {
      return expect(true).toBe(true);
    });
    it("@hslToRgb:( hsl ) ->", function() {
      return expect(true).toBe(true);
    });
    it("@hue2rgb:( p, q, t ) ->", function() {
      return expect(true).toBe(true);
    });
    it("@rgbsToHsl:( red, green, blue ) ->", function() {
      return expect(true).toBe(true);
    });
    return it("@rgbToHsl:( rgb ) ->", function() {
      return expect(true).toBe(true);
    });
  });

  describe("util/Type.coffee", function() {
    it("@isType:( type )         ->", function() {
      return expect(true).toBe(true);
    });
    it("@toType:( decl )         ->", function() {
      return expect(true).toBe(true);
    });
    it("@typeJS:( type )         ->", function() {
      return expect(true).toBe(true);
    });
    it("@convert:( value, type ) ->", function() {
      return expect(true).toBe(true);
    });
    it("@align:(  type )         ->", function() {
      return expect(true).toBe(true);
    });
    it("@cell:( value, type )    ->", function() {
      return expect(true).toBe(true);
    });
    it("@toObjType:( obj )       ->", function() {
      return expect(true).toBe(true);
    });
    it("@toClass:( obj )         ->", function() {
      return expect(true).toBe(true);
    });
    it("@isoDateString:( date )  ->", function() {
      return expect(true).toBe(true);
    });
    return it("@toFixed:( arg, dec )    ->", function() {
      return expect(true).toBe(true);
    });
  });

  describe("util/Pallettes.coffee", function() {
    it("@color:( nameHex )        ->", function() {
      return expect(true).toBe(true);
    });
    it("@colorName:( name )       ->", function() {
      return expect(true).toBe(true);
    });
    it("@colorHex:( hex )         ->", function() {
      return expect(true).toBe(true);
    });
    it("@hexdec:( name )          ->", function() {
      return expect(true).toBe(true);
    });
    it("@hex:( code )             ->", function() {
      return expect(true).toBe(true);
    });
    it("@hexGroup:( group, code ) ->", function() {
      return expect(true).toBe(true);
    });
    return it("@hexes:( group, c )       ->", function() {
      return expect(true).toBe(true);
    });
  });

  describe("util/GeoJson.coffee", function() {
    it(" boundingBoxAroundPolyCoords:(coords)            -> ", function() {
      return expect(true).toBe(true);
    });
    it(" pnpoly:(x, y, coords)                           -> ", function() {
      return expect(true).toBe(true);
    });
    it(" lineStringsIntersect:(l1, l2)                   -> ", function() {
      return expect(true).toBe(true);
    });
    it(" pointInBoundingBox:(point, bounds)              -> ", function() {
      return expect(true).toBe(true);
    });
    it(" pointInPolygon:(p, poly)                        -> ", function() {
      return expect(true).toBe(true);
    });
    it(" pointInMultiPolygon:(p, poly)                   -> ", function() {
      return expect(true).toBe(true);
    });
    it(" numberToRadius:(number)                         -> ", function() {
      return expect(true).toBe(true);
    });
    it(" numberToDegree:(number)                         -> ", function() {
      return expect(true).toBe(true);
    });
    it(" drawCircle:(radiusInMeters, centerPoint, steps) -> ", function() {
      return expect(true).toBe(true);
    });
    it(" rectangleCentroid:(rectangle)                   -> ", function() {
      return expect(true).toBe(true);
    });
    it(" pointDistance:(pt1, pt2)                        -> ", function() {
      return expect(true).toBe(true);
    });
    it(" geometryWithinRadius:(geometry, center, radius) -> ", function() {
      return expect(true).toBe(true);
    });
    it(" area:(polygon)                                  -> ", function() {
      return expect(true).toBe(true);
    });
    it(" centroid:(polygon)                              -> ", function() {
      return expect(true).toBe(true);
    });
    it(" simplify:(source, kink)                         -> ", function() {
      return expect(true).toBe(true);
    });
    return it(" destinationPoint:(pt, brng, dist)               -> ", function() {
      return expect(true).toBe(true);
    });
  });

}).call(this);
